---
title: "Data.table refresher and deep dive learning"
author: "Leslie Emery"
date: "6/27/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introduction to data.table
https://cloud.r-project.org/web/packages/data.table/vignettes/datatable-intro.html

*2019-06-27*
```{r}
install.packages('data.table')
library(data.table)
```

```{r get-data}
input <- if (file.exists("flights14.csv")) {
   "flights14.csv"
} else {
  "https://raw.githubusercontent.com/Rdatatable/data.table/master/vignettes/flights14.csv"
}
# fread makes this a data.table from the start
flights <- fread(input) # Will also read a file from the internet - that's neat!
str(flights)
```

## 1 Basics
```{r}
# Create a data.table from scratch
DT <- data.table(
    ID=c('b', 'b', 'b', 'a', 'a', 'c'),
    a=1:6, 
    b=7:12,
    c=13:18
)
str(DT)
### data.tables have stringsAsFactors=False as the default!!! ###
getOption('datatable.print.nrows')

# Using indexes in the brackets of a DT is "querying" a data.table
# Subset rows
flights[1:2, ]
flights[origin == 'JFK' & month == 6]
dim(flights[origin == 'JFK' & month == 6])
# Note that the column names can be used as if named variables, within the brackets

# Reorder rows
flights[order(origin, -dest), ]

# Select columns
flights[ , arr_delay] # Returns a vector
flights[["arr_delay"]] # Returns a vector
flights$arr_delay # Returns a vector
flights[ , list(arr_delay)] # Returns a data.table
flights[ , .(arr_delay)] # .() is just an alias for list()

flights[ , .(arr_delay, dep_delay)]
flights[ , .(arrival_delay=arr_delay, departure_delay=dep_delay)] # Use the j query list to rename the selected columns

# You can compute in the j query
flights[ , sum( (arr_delay + dep_delay) < 0)] # Number of flights without any delay
# This is like dplyr's mutate, but it's just using the same syntax in the same place
# You can also combine these computations in j with queries in i
flights[origin == 'JFK' & month == 6, .(avg_arr_delay=mean(arr_delay), avg_dep_delay=mean(dep_delay))]
# This is pretty fast because it subsets just the indexes of i, and the right columns in j, before doing the computation
# The query is optimized before evaluation

# You could use the computation in j to count the rows in your query
flights[origin == 'JFK' & month == 6, .(length(dest))]
# But there's also a special shortcut for this
flights[origin == 'JFK' & month == 6, .N] # And there's no stupide V1 variable name

# You can index by column name in a variable or vector as well
flights[ , c('arr_delay', 'dep_delay')]
# And unpack a vector with ..
select_cols <- c('arr_delay', 'dep_delay')
flights[ , ..select_cols]
# Or use the with=FALSE argument
flights[ , select_cols, with=FALSE]
# You can exclude columns in this way
flights[ , -c('arr_delay', 'dep_delay')]
# And select or exclude a range of columns by variable name
flights[ , year:day]
flights[ , -(year:day)]
```

## 2 Aggregations
*2019-06-28*
- The `by` argument to a data.table provides grouping (aggregation) functions
- The original order of the groups in the unaggregated data.table is preserved in the grouping process
- `keyby` is usually faster than `by` because the sorting needs to be done under the hood anyway in order to carry out the grouping
    - Note that `keyby` also sets a key at the same time
```{r}
flights[ , .(.N), by=.(origin)] # Total number of flights originating in each airport
flights[ , .(.N), by='origin'] # Works with a character vector too
flights[ , .(number_of_flights=.N), by=.(origin)] # Provide a column name for the new aggregated variable
flights[ , .N, by=origin] # The .() notation isn't needed when there's just one variable in j or by
flights[carrier == 'AA', .N, by=origin] # You can do subsetting with i at the same time
flights[ , .N, by=.(origin, dest)] # You can group by multiple variables
# And combine with as many j variables as you want
flights[ , .(avg_arr_delay=mean(arr_delay), avg_dep_delay=mean(dep_delay)), by=.(origin, dest, month)]
# Just change by to keyby and you'll get sorting on the by variables as well
flights[ , .(avg_arr_delay=mean(arr_delay), avg_dep_delay=mean(dep_delay)), keyby=.(origin, dest, month)]
# Chaining the expressions prevents having to write the data.table to a new variable
flights[carrier == 'AA', .N, by=.(origin, dest)][order(origin, -dest), ]
# You can also put expressions in by/keyby
flights[ , .N, by=.(dep_delay>0, arr_delay>0)]
# And you can include other variables at the same time as an expression
flights[ , .N, by=.(dep_delay>0, arr_delay>0, origin)]
```

- `.SD` is a special symbol, standing for "Subset of Data"
    - `.SD` represents the data for the current group defined in by/keyby
    - `.SD` contains all columns *except for the grouping columns*
    - An additional argument, `.SDcols`, can be combined with `.SD` to do things on specified subsets of columns
```{r}
# What does .SD look like?
DT
DT[ , print(.SD), by=ID]
# A list of the three groups of data, where ID=a, ID=b, and ID=c
# If you use just .SD it would calculate on all possible columns
DT[ , mean(.SD), by=ID] # Doesn't work because it's on the whole group
DT[ , lapply(.SD, mean), by=ID] # Need to use lapply
# So get the mean of just a couple of columns
flights[carrier == 'AA', lapply(.SD, mean), by=.(origin, dest, month), .SDcols=c('arr_delay', 'dep_delay')]
# And there are many ways to specify the columns you want
str(flights)
flights[carrier == 'AA', lapply(.SD, mean), by=.(origin, dest, month), .SDcols=!c('year', 'day', 'carrier')]
flights[carrier == 'AA', lapply(.SD, mean), by=.(origin, dest, month), .SDcols=-c('year', 'day', 'carrier')]
flights[carrier == 'AA', lapply(.SD, mean), by=.(origin, dest, month), .SDcols=air_time:hour]
# Getting the first two rows for each group
flights[ , head(.SD, 2), by=month]
# Combine with a function and lapply in j to get mean of first two rows for arr_delay and dep_delay
flights[ , lapply(head(.SD, 2), mean), by=month, .SDcols=c('arr_delay', 'dep_delay')]
```

- The syntax of data.tables is so flexible that it is very, very powerful and you can do almost anything you can imagine with a data.table using just i, j, and by
```{r}
# Combine two columns of a data.table into one
DT[ , .(val=c(a, b)), by=ID] # But how would you get the a/b labels with this???
# Make the result into a list instead
DT[ , .(val=list(c(a,b))), by=ID]
```

## Key points
- `data.table` syntax is `DT[i, j, by]
- i can subset rows and use `order()` to sort the rows
- j can select columns, compute on columns, and combine with i behaviors
- by can perform aggregation by specified columns, and keyby can sort at the same time
    - .SD and .SDcols can be used to compute on the aggregated columns
- **As long as j returns a list, each element will be a column in the resulting data.table!**